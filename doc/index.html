<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Core package documentation</title>
    <link rel="stylesheet" type="text/css" href="http://ontology.it/tools/bofw/v4/css/doc.css">
  </head>
  <body>
    <header>
      <div class="jumbotron">
        <h1>Core package</h1>
        <p id="subject"> Super lightweight classes for developing cool RESTful APIs. </p>
      </div>
      <div class="metadata">
        <dl id="metadata">
          <dt>Author:</dt>
          <dd id="creator">
            <address> Enrico Fagnoni - <a href="http://www.e-artspace.com/home/about">E-Artspace</a> </address>
          </dd>
          <!-- here other autogenerated metadata -->
        </dl>
      </div>
      <section id="abstract">
        <h2>Abstract</h2>
        <p> Core package is part of the <a href="../overview/">Business Ontology ToolKit (BOTK)</a>. This package
          contains a set of classes implementing a specialized Model-View-Controller architecture for the development of
          HTTP RESTful APis. </p>
      </section>
      <section id="status">
        <h2>Package Status</h2>
        <p> Develop master branch (trunk) is changing on a daily if not hourly basis. Contributions are very welcome,
          please send them to the authors. Thank you. </p>
        <p> No stable release yet available. </p>
      </section>
      <section id="license">
        <h2>License</h2>
        <details> <summary id="rightsHolder"> Copyright © 2013 by <a href="http://www.e.artspace.com/">E-Artspace
              S.r.L.</a><sup>®</sup> GPL-3.0+ </summary>
          <p> This code is free software; you can redistribute it and/or modify it under the terms of the <a href="http://www.gnu.org/licenses/gpl.html">GNU
              General Public License</a> as published by the Free Software Foundation; either version 3.0 of the
            License, or (at your option) any later version. This code is distributed in the hope that it will be
            useful,but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
            PARTICULAR PURPOSE. See the GNU General Public License for more details. </p>
          <p> <strong> For commercial license or others license schema, please contact <a href="http://www.e-artspace.com/">E-Artspace</a>
              or authors. </strong> </p>
        </details> </section>
    </header>
    <nav>
      <h2>Table of contents</h2>
      <div id="toc">
        <!-- autogenerated toc--> </div>
    </nav>
    <section>
      <h1 id="install">Installation</h1>
      <p> This package follows<a href="../overview/#installation"> BOTK guideline for installation</a> and require <a href="http://getcomposer.org/">composer</a>.
      </p>
      <p> Add following dependance to <strong>composer.json</strong> file in your project root: </p>
      <pre><code>{
    "minimum-stability": "dev",
    "require": {
        "botk/core": "dev-trunk"
    }
}
</code></pre> </section>
    <section>
      <h1 id="overview">Overview</h1>
      <p> Core package libraries are designed to implement <a href="http://en.wikipedia.org/wiki/Restful#RESTful_web_APIs">RESTful
          Web APIs</a> according with the <a href="http://en.wikipedia.org/wiki/Restful#Constraints">RESTful
          constraints</a> and taking into account the best practice in APIs design (for instance see <a href="http://apigee.com/about/api-best-practices">Apigee
          Api Best Practice books</a> ). </p>
      <p> You can use Core Package to develop: </p>
      <ul>
        <li> <strong>web applications</strong> : just PHP <a href="http://www.ietf.org/rfc/rfc3875">CGI 1.1 interface</a>
          scripts. </li>
        <li> <strong>RESTful APIs</strong>: web applications that accept the RESTfull architectural constraints. </li>
        <li> <strong>BOful APIs</strong>: RESTFul APIs using Semantic Web Architecture according <a href="../overview/">BOTK
            specifications</a>. </li>
      </ul>
      <p> Core package is an extension of <a href="http://github.com/Respect/Rest">Respect\Rest</a> library and it is
        designed for having a minimum memory footprint and minimum overhead on servers. </p>
      <p> The following code snippet is a simple RESTful API that represents the string '"Hello world". It manages <a href="#contentNegotiation">HTTP
          Content negotiation</a> supporting: application/json, application/xml, text/html, application/x-php,
        text/x-php, text/plain. It also <a href="#errorManagement">manages errors</a> according last available <a href="http://tools.ietf.org/html/draft-nottingham-http-problem-04">http_problem
          proposal</a> RFC, rendering <em>http problem</em> as:&nbsp; application/api-problem+json,
        application/api-problem+xml, text/html, application/x-php, text/x-php, text/plain. </p>
      <pre><code>require '../vendor/autoload.php';
use BOTK\Core\EndPoint, BOTK\Core\EndPointFactory, BOTK\Core\ErrorManager,
    BOTK\Core\Representations\Standard;

class MyEndPoint extendsEndpoint {
    protected function setRoutes() { 
        $this-&gt;get('/', 'Hello world')-&gt;accept(Standard::renderers()); 
    }
}

try {                                                      
    echoEndpointFactory::make('MyEndPoint')-&gt;run();
} catch ( Exception $e) {
    echo ErrorManager::getInstance()-&gt;render($e); 
}</code><code>
</code></pre> <br>
      Core package is designed around the endpoint concept:
      <blockquote>
        <p> An endpoint&nbsp; is a Web service that provides server side <a href="http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_APIs">RESTful
            web API</a>. An endpoint can be described with <a href="http://tools.ietf.org/html/rfc6570">URI templates</a>
          and implemented in a <a href="http://www.ietf.org/rfc/rfc3875">CGI</a> script. </p>
        <small>BOTK definition of an endpoint</small> </blockquote>
      <p> Core package implements endpoints inEndpoint<a href="#EndPoint"> class</a>. </p>
      <p> The Core package is a killer one, i.e. it is a really sophisticated package which provides a powerful way to
        implement web services. Even if the Core package is focused to <a href="http://en.wikipedia.org/wiki/Web_API#Server-side">server-side
          APIs</a>, with it you can do nearly all types of web application you ever dreamed about. The price you have to
        pay is to accept complexity, because Core package major drawback is that it is not easy to understand and to use
        at the beginning. <br>
        <br>
        In other words: with Core Package you either shoot yourself in the foot the first time and never use it again or
        love it for the rest of your life because of its power. </p>
      <p> Core package follows the BOTK "non framework" philosophy, that is that grants you the freedom to adopt or
        reject BOTK guidelines and/or best practices. Find your way to use Core Package! </p>
      <h2 id="architecture">Architecture</h2>
      <p> Like in many PHP frameworks, Core package adopts <a href="http://en.wikipedia.org/wiki/Model_view_controller">Model–view–controller</a>
        (MVC) design pattern adapting it to RESTful architecture. </p>
      <p> Classical MVC design pattern separates the application into three parts: </p>
      <ul>
        <li> The <strong>Model</strong> models your business objects, the "things" in your application, wrapping up
          data handling and logic. </li>
        <li> The <strong>View</strong> manages the application output. </li>
        <li> The <strong>Controller</strong> manages the application flow manipulating data from the Model and driving
          views. </li>
      </ul>
      <p> MVC has been widely embraced by Web developers even though it was designed for desktop applications. MVC
        doesn't really maps perfectly well on the Web, because it doesn't model and expose resources in a convenient way
        (actions are methods on controllers exposed as resources rather than methods on resources themselves). Core
        package adapts of the classic MVC to web architecture, and in particular to RESTful APIs architecture: </p>
      <ul>
        <li> the "C" part of MVC (i.e. Controller) is realized with a set of classes to control various aspect of HTTP
          protocol : </li>
        <li>
          <ul>
            <li> <a href="#EndPoint"><em>EndPoint</em></a> manages <a href="http://tools.ietf.org/html/rfc6570">Uri
                templates</a> and <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP request
                headers</a> throw routes to a resource controller method and routines. It controls <a href="http://en.wikipedia.org/wiki/Content_negotiation">HTTP
                content negotiation</a>, <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">HTTP cache
                management</a> and out-of band processes like logging and billing. </li>
            <li> <a href="#Controller"><em>Controller</em></a> controls the HTTP protocol for a single resource. It is
              responsible for <strong>resource model</strong> instantiation, for <strong>resource state transitions</strong>.
            </li>
          </ul>
        </li>
        <li> The "V" part of MVC (i.e. View) is realized by <a href="#renderer">renderers</a> that produce resource
          state representation in HTTP response managing the production of a proper&nbsp; response content type header
          (normally calling <a href="#serializer">serializers</a>). </li>
        <li> The "M" part (i.e. Model) are implemented as any PHP data structure (scalar, array, streams or classes) and
          refers to Web Resource.Core package frees you to chose what paradigm use for&nbsp; <strong>Resource Modelling</strong>:
          you can follow a pure object oriented approach and putting data (i.e. <em>properties</em>) and functions (<em>methods</em>)
          together inside the model itself, or you can follow the web architecture keeping separate data (<em>resource
            state</em>) from functions (<em>resource manager</em>). Core package supports the restoring of a Resource
          State from its representations through <a href="#parser">parsers</a> that read a specific resource state
          representations in HTTP request and translate them in a PHP data model (that is a scalar or an associative
          array of 'property' =&gt; 'value', or a PHP parsable program).. </li>
      </ul>
      <p> Parsers and renderers are defined in <a href="contentNegotiation">Content Negotiation Policies</a> that group
        all <strong>resource state representation management</strong> functions. </p>
      <p> Core package enforces a strict <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation for
          concerns</a> between Applications,Endpoints, Controllers and Content Negotiation Policies: </p>
      <figure> <img id="mvc" alt="Core as MVC implementation" src="images_file/png_1.png"> <figcaption> Core classes
          vs MVC </figcaption> </figure>
      <br>
      <p> This approach allows you to write reusable endpoints as in this RESTful web service example: </p>
      <pre><code>require '../vendor/autoload.php';

use BOTK\Core\EndpointFactory,          // Create endpoint
    BOTK\Core\EndPoint,                 // provides the web service runtime
    BOTK\Core\Controller,               // controls http protocol
    BOTK\Core\ErrorManager,             // Controls errors
    BOTK\Core\Representations\Standard, // provides many resource representations
    BOTK\Core\WebLink,                  // add hypermedia capability
    BOTK\Core\Caching;                  // manage HTTP caching

/* This class implements MVC Model */
class Greeting
{
    public $greeting = 'Hello', $to = '', $by = 'http://www.e-artspace.com/';  
    public function __construct($to='World') { $this-&gt;to=$to;}
    public function __toString() {return "$this-&gt;greeting $this-&gt;to";}
}

/* This class implements MVC View */
class GreetingRepresentation extends Standard {}

/* This class implements MVC Controller for Resource*/
class HelloworldController extends Controller
{
    public function get($to='World')
    {
        return $this-&gt;stateTransfer(
            $hello = new Greeting($to),
            WebLink::factory($hello-&gt;by)-&gt;rel('next')
        );
    }
}

/* This class implements MVC Controller for endpoint*/
class Helloworld extendsEndpoint
{
    protected function setRoutes()
    {
        $this-&gt;get('/*', new HelloworldController)
            -&gt;accept(GreetingRepresentation::renderers())
            -&gt;through($this-&gt;representationCachingProcessor(Caching::SHORT));
    }
}

//uncomment above to use your css:
//Standard::$htmlMetadata = 'http://www.w3.org/StyleSheets/Core/parser.css?family=6&amp;doc=XML';
try {                                                      
    echoEndpointFactory::make('Helloworld')-&gt;run();
} catch ( Exception $e) {
    echo ErrorManager::getInstance()-&gt;render($e); 
}</code><code>
</code></pre>
      <p> This simple implementation provides json, html, xml, PHP and text representation of a web resource, whose
        state is modeled as a simple PHP object. It advertises the next resource you can visit after getting its
        representation in any format. The web service informs the client that it can safely cache it for at least 30
        sec.(see <a href="#httpCaching">Caching chapter</a> for more info). Note that default <code> stateTransfer() </code>
        processor provided by Core\Controller implements hyperlinks as required by RESTfull architecture. And all of
        this for a small price of about 300KB of memory footprint, using uncompressed PHP code! That's will be, more or
        less, the overhead of using Core package on your specific application code.&nbsp; </p>
      <section>
        <h2 id="dataFlow">Data Flow</h2>
        <p> The data flow is managed in four phases </p>
        <ol>
          <li> HTTP request parsing </li>
          <li> endpoint workflow </li>
          <li> resource controller workflow </li>
          <li> HTTP response emission </li>
        </ol>
        <h3 id="request">Request parsing</h3>
        <p> Request parsing splits an HTTP request in pieces of manageable information.Core package rely on PHP way to
          parse HTTP request that in turn rely on <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>
          (Common Gateway Interface) to manage HTTP protocol. HTTP Request information are contained in PHP superglobal
          variables <a href="http://www.php.net/manual/en/reserved.variables.server.php">$_SERVER</a>, <a href="http://www.php.net/manual/en/reserved.variables.files.php">$_FILES</a>,
          <a href="http://www.php.net/manual/en/reserved.variables.get.php">$_GET</a>, <a href="http://www.php.net/manual/en/reserved.variables.post.php">_POST</a>.
          Request body is available as php://input or STDIN stream. Because of stateless nature of RESTful web
          applications<strong> you are discouraged to use cookies and session variables</strong>. In core Package ther
          is no support for such HTTP protocol parts. Here is a summary of Core supported HTTP request parts: </p>
        <figure> <img id="httpRequest_pic" alt="Http request parsing" src="images_file/png_3.png"> <figcaption> Php
            HTTP request parsing. </figcaption> </figure>
        <p> BOTK <a href="../context/">Context package</a> add some facility and helpers to access to PHP HTTP
          variables together with configuration and environment information. </p>
        <h3 id="endpointWorkflow">EndPoint workflow</h3>
        <p> TheEndpoint workflow objective is to route an HTTP request to a function that manage it. The role of
          endpoint consists in: </p>
        <ul>
          <li> selecting the appropriate action controller and route to it the client request to one using one of the
            HTTP methods (get, put, post, etc.) exposed by a Controller. </li>
          <li> to manage content negotiation </li>
          <li> to manage HTTP caching of resource state final representation (i.e. checks if resource representation is
            changed) </li>
          <li> to manage other out-of-band business logic like logging and billing </li>
        </ul>
        <p> Here a simplified picture of internal dataflow for aEndpoint class: </p>
        <figure> <img style="width: 742px; height: 484px;" id="endpoint_pic" alt="EndPoin tDataflow" src="images_file/png_4.png">
          <figcaption> EndPoint dataflow </figcaption> </figure>
      </section>
      <h3 id="controllerWorkflow"> Resource Controller workflow</h3>
      <p> The controller workflow objective is to provide an implementation for HTTP method to serve an client request.
        The responsibility of the Controller is: </p>
      <ul>
        <li> to validate request </li>
        <li> to instantiate resources models </li>
        <li> to apply business logic </li>
        <li> to define next steps in application workflow </li>
        <li> to manage caching at Resource Model level (i.e. checks if model is changed) </li>
      </ul>
      <p> Here a simplified picture of internal dataflow for a controller class: </p>
      <figure> <figcaption> Controller dataflow </figcaption> <img style="width: 768px; height: 468px;" id="controller_pic"
          alt="Controller dataflow" src="images_file/png_5.png"> </figure>
      <br>
      <h3 id="response">HTTP Response emission</h3>
      <p id="httpRequest"> Core package rely on PHP to emit response request. All you echo in application will be route
        to response body bypass content management. </p>
      <figure> <img id="httpResponse_pic" alt="Http request parsing" src="images_file/png_6.png"> <figcaption> Php
          HTTP response emission. </figcaption> </figure>
      <p> BOTK Context package add some facility and helpers to access to PHP HTTP variables together with configuration
        and environment information. </p>
      <section>
        <h2 id="how">How Core package helps your APIs to be RESTfull</h2>
        <p> According to<a href="http://www.ics.uci.edu/%7Etaylor/documents/2002-REST-TOIT.pdf"> Roy T. Fielding and
            Richard Taylor dissertation</a>, the REST architectural style is derived from six constraints applied to the
          architecture. This chapter analyze such constraints and give you some hints about how using Core Package and
          PHP to be RESTful compliant. </p>
        <blockquote>
          <p> A uniform interface separates clients from servers... </p>
          <small>Client–server</small> </blockquote>
        <p> Use HTTP 1.1 as the only application protocol for client server interface.The Core package concerns the
          implementation of server side and supports uri templates. </p>
        <blockquote>
          <p> Each request from any client contains all of the information necessary to service the request, and session
            state is held in the client... </p>
          <small>Stateless</small> </blockquote>
        <p> Core package never use $_SESSION and $_COOKIES superglobals . To enforce this style guide consider using <a
            href="../context/">Context Package</a>. </p>
        <blockquote>
          <p> As on the World Wide Web, clients can cache renderers... </p>
          <small>Cacheable</small> </blockquote>
        <p>Endpoints and Controller class provide a set of facilities to manage HTTP cache headers. See <a href="#httpCaching">HTTP
            Caching chapter</a> for more info. </p>
        <blockquote>
          <p> A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary
            along the way... </p>
          <small>Layered system</small> </blockquote>
        <p> Core Web services can be be called from any CGI capable web server (not only Apache) using preferred
          technology (fastCGI, mod_php, cgi, etc). Core package doesn't&nbsp; use proxy related headers to drive
          actions. </p>
        <blockquote>
          <p> Servers can temporarily extend or customize the functionality of a client by the transfer of executable
            code... </p>
          <small>Code on demand</small> </blockquote>
        <p> The content negotiation standard policies support "text/x-php" that allow clients to receive the response
          body as an executable PHP program. Beside this, in Standard Content Negotiation Policy, any textual data
          representation (both in tex/plain and in html) is expressed as PHP interpretable code) See <a href="#contentNegotiation">Content
            Negotiation Chapter</a> for for more info. </p>
        <blockquote>
          <p> The uniform interface between clients and servers, simplifies and decouples the architecture, which
            enables each part to evolve independently... </p>
          <small>Uniform interface</small> </blockquote>
        <p> Core package does not impose a uniform content type for response but supports different resource
          representation (json, xml, html, etc.) through content negotiation .Both for requests and responses. </p>
        <p id="HypermediaModel"> Beside this, <strong>Roy T. Fielding stressed that <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">REST
              APIs must be hypertext driven</a></strong>. Unfortunately many formats typically used to serialize the
          status odf web resources (i.e, json, plain xml, plain text) do not support hyperlinks and metadata. <strong>BOTK
            suggests RDF as preferred hypermedia data model</strong>. The BOTK support to <a href="../rdf/">RDF is
            available as a separate package</a>.&nbsp; By the way, <a href="#Controller">Core\Controller</a> use Web
          Links in HTTP header to provide an Uniform hypermedia&nbsp; interface between client and server for all non
          hypermedial formats . </p>
      </section>
      <h2 id="why">Why to be RESTfull </h2>
      <p> Conforming to the REST architectural-style, enables any kind of distributed hypermedia system to have
        desirable emergent properties, such as performance, scalability, simplicity, modifiability, visibility,
        portability, and reliability. </p>
      <p> Please note that if a web service service violates any of the required constraints, it cannot be considered
        RESTful. </p>
      <h1 id="EndPoint">EndPoint Class</h1>
      <p> <code> Core\EndPoint </code> is the the entry point of web services resource processing. </p>
      <p>Endpoint is able to manage simplified <a href="http://en.wikipedia.org/wiki/URL_Template">URI template</a> but
        is not able to route using <a href="http://en.wikipedia.org/wiki/Query_string">URI query string</a> nor <a href="http://en.wikipedia.org/wiki/Fragment_identifier">URI
          Fragment</a>.Endpoint it is a specialization of <code><a href="">Respect\Rest\Router</a></code> Class. </p>
      <p> Best practice is to route HTTP request methods to one or more Action Controllers, but anEndpoint it is able to
        route directly to a closure function or even to a string: </p>
      <pre><code>final class HelloWorldEndPoint extendsEndpoint
{
  protected function setRoutes()
  {
    // route HTTP GET method to a string
    $this -&gt;get('/helloworld', 'Hello World');

    // route HTTP GET method  to a closure
    $this -&gt;get('/sayHello', function(){ return  'Hello World';});

    // route HTTP GET method to a closure (with template)
    $this -&gt;get('/hi/*', function($x='hello'){ return  "Hello $x";});

    //route to a controller class ( that will be instanced runtime )
    $this -&gt;any('/hello/*', 'MyHelloController'); // be sure to implements all method if use any.

    //Best practice: route to your instanced controller
    $this -&gt;get('/hello/*', new MyHelloController);
  }
}</code></pre>
      <p> <code> Core\EndPoint</code> class is also able to mount other existing endpoints. It is easy to build complex
        RESTful APIs composing a set of smaller and reusable components. Endpoint class is able to allocate run time
        only the needed endpoint. This feature helps to minimize the run-time memory footprint because it avoids the
        loading and parsing of unnecessary code:</p>
      <pre><code>echo EndpointFactory::make()
      -&gt;mountEndPoint('users', 'UsersEndPoint')
      -&gt;mountEndPoint('hello', 'HelloWorldEndPoint')
      -&gt;run();      </code></pre>
      <p>Endpoint class add some value to Respect\Rest\Router class: </p>
      <ul>
        <li> can mount existing endpoints as routes allocating run-time just when needed, this allow a memory
          optimization and a better code cleanness. </li>
        <li> can detects virtualhost from CGI variables auto-detecting the most common url rewriting done by web
          servers. </li>
      </ul>
      In any case you can use all Respect\Rest features.See <a href="http://github.com/Respect/Rest">Respect\Rest</a>
      documentation for more info. </section>
    <section>
      <h1 id="Controller">Controller Class</h1>
      <p> The Core\Controller is a class that implement actions for standard <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">HTTP
          request methods</a> (get, put, post,delete, options,head) . Note that Controller is completely decoupled from
        routing and content negotiation. </p>
      <p> The best practice is that a controller should take no assumption about how to read/write resource state
        letting this job to content management policies. Core\Controller it is the closest thing to the C in MVC, BOTK
        controller takes care to instantiate a Model decoupling HTTP flow management from data business logic. </p>
      <p> This is a short snippet of a simple Controller implementation: </p>
      <pre><code>class MyRESTfulController extends Controller
{
    public function get()
    {
        $obj= new ResourceModel;
        $this-&gt;setState( $obj, Representations\Standard::restorers());

        return $this-&gt;stateTransfer(
            Caching::resouce($obj, Caching::CONSERVATIVE),
            WebLink::factory('HTTP://myDomain/')-&gt;rel('copyright')
        );
    }
}<br></code></pre>
      In any case controller can bypass hypermedial state transfer processing returning the data: <br>
      <pre><code>class QuickController extends Controller
{
    public function get()
    {
        return new MyResourceModel;
    }
}</code></pre>
      <p> Or even bypass all best practice and just directly output content body: </p>
      <pre><code>class QuickAndDirtyController extends Controller
{
    public function get()
    {
        </code><code><code>echo </code>'hello world';
    }
}</code></pre>
    </section>
    <section>
      <h1 id="model">Data modelling</h1>
      <p> Core package doesn't impose any constraint on resource data models. In principle you can use a scalar, an
        array or anything that you can model as PHP data: </p>
      <pre><code>class WorldModel
{
  public $helloTo = 'everybody';
}</code></pre>
      <p> Note that&nbsp; you can decide to follow a pure object oriented approach and putting data (i.e. <em>properties</em>)
        and functions (<em>methods</em>) together inside the resource model itself, or you can follow the web
        architecture keeping separate data (<em>resource state</em>) from functions (<em>resource manager</em>). </p>
      <p> By the way in web architecture the resource is something supposed to be serialized in one or more formats, so
        your data model should be mandatory recognized by representation renderers. More, in RESTful architecture a
        model should derive its status from a content provided by client (POST, Put and PATCH methods), so happens that
        external representations sometime need also to be parsed and restore a Resource model. </p>
      <p> For these reasons in Core Package Data models are bonded to Content Management policies that provides all
        renderers and parsers. Note that in content management policy the resource state representation renders are
        completely disjointed from the resource state representation parsers. Normally parsers supports a subset of
        provided renderers. </p>
      <p> Core package provides a set of ready to use content management policy to support the rending an the parsing
        main PHP data structure and in particular: </p>
      <dl>
        <dt>Standard content management policy</dt>
        <dd> renderers any PHP serializabile data structure in json, xml,html, PHP serialized, and plain text. It
          provides restorers that automatically build StdClass, scalar or Array for application/json,
          application/core+xml and serialized PHP content type. </dd>
        <dt>Error content management policy</dt>
        <dd> renderers Core\Models\Error data structure in json, xml,html, PHP serialized, and plain text. It provides
          no restorers. </dd>
      </dl>
    </section>
    <section>
      <h1 id="contentNegotiation">Content Negotiation</h1>
      <p> &nbsp;<a href="http://en.wikipedia.org/wiki/Content_negotiation">HTTP Content negotiation</a> is managed as a
        part of dynamic, non binding contract between a client and a server to exchange a Resource Representation State.
        In Core package, content negotiation is the result of a cooperation between: </p>
      <ul>
        <li> a<em> content negotiation policy</em> issued by server </li>
        <li> an <em>accept header</em> submitted by client </li>
        <li> a set of <em>renderer</em> functions that build an HTTP response rendering a resource in a specific
          content type using a serializer </li>
        <li> a set of <em>serializer</em> functions that transform a resource data structure in a utf8 encoded strings
        </li>
        <li> a <em>Content-Type header</em> provided by client as request body </li>
        <li> a <em>resource Model</em> </li>
        <li> <em><em>a set of </em>restorer</em> function that restore the Resource Model state using the data
          provided by client, and a proper selected parser. </li>
        <li> <em><em>a set of </em>parser</em> functions that read the resource state provided by clients according a
          specific format </li>
      </ul>
      <h2 id="actors">Content negotiation actors</h2>
      <h3 id="renderer">Renderers</h3>
      <p> A renderer is a functions that detects, selects, calls serializers and sends to client proper HTTP <code>
          Content-Type </code> header. A renderer is a PHP function that expose a standard interface accepting a PHP
        data structure as the only parameter. Its role is to manage Content-Type header in response and call a
        serializer with the right parameters. Renderers is also responsible to look inside input data to see if exposes
        specialized <a href="#serializer">serializers</a>. Renderers functions are normally (but non mandatory)
        implemented as static methods in content negotiation policies. For example: </p>
      <pre>    public static function htmlRenderer($data)
    {
        header('Content-Type: text/html');
        if ( is_object($data) &amp;&amp; method_exists($data,'saveHTML')){
            return $data-&gt;saveHTML();
        } else {
            return  '&lt; pre&gt; '.(is_scalar($data) ? $data : print_r($data, true)).'&lt; /pre&gt; ';
        }
    }</pre>
      <p> <strong>By default renderers should expose only public variables in data model</strong>. </p>
      <p> Renderers should provide HTTP weblinks to alternate formats available for the same resource; this is
        automatically performed by the function <code> setContentType()</code> provided by <code>
          AbstractContentNegotiationPolicy</code> class: </p>
      <pre>   public static function htmlRenderer($data)
    {
        static::setContentType('text/html');
...
</pre>
      <h3 id="serializer">Serializers</h3>
      <p> A serializer is an helper function that translate a data model into a utf8 string according with a specific
        format. </p>
      <p> <a href="#Standard">Representations\Standard</a> provides default serializers to all those objects that do
        not expose their own custom serializers and to non object data structures (arrays and scalars). </p>
      <h3 id="parser">Parsers</h3>
      <p> A parser is a function that accept a string that is supposed to contain a serialization of a resource state in
        a specific format and returns a resource state as a PHP associative array structure that contains property value
        pair or a string as produced from a <a href="http://php.net/manual/en/function.var-export.php"><code>
            var_export()</code></a> PHP standard function. </p>
      <h3 id="policy">Content negotiation policies</h3>
      <p> Content negotiation policies are libraries to provide renderes, serializer, restorers and and parsers<strong>
          for a specific set of Resource Model Types</strong>. Content negotiation policies are managed by <a href="#accepting">accept
          process</a> , by Status <a href="#restoring">restore process</a> , by <a href="#ErrroManager">error
          management</a> and by who need to read an HTTP content body request or to write an HTTP content body response.
      </p>
      <p> Content negotiation policy is represented in Core package with <code>
          Representations\AbstractContenNegotiationPolicy </code> class. Content negotiation policies should provide
        only static data and functions, so you do not need to instance them. </p>
      <p> Content negotiation policies contains <em>representations</em> that are associative array of a key ( a medium
        mimetype or a language id) and a <em>content processor function</em> that accepts as the only parameter the
        resource model (i.e. a PHP variable) and process it . A content negotiation policies provides: </p>
      <dl>
        <dt>response representations</dt>
        <dd> implemented with the protected associative array <code> $renderers </code> that associate a mime type
          with a <a href="#renderer">renderer</a>. Content negotiation policy provide the public <code> renderers() </code>
          function that returns $renders variable. </dd>
        <dt>request representations</dt>
        <dd> implemented with the protected associative array <code> $parsers </code> that associate a mime type with
          a parser. Content negotiation policy provide the public <code> restorers() </code> function that returns
          $restorers variable . </dd>
        <dt>language translators</dt>
        <dd> implemented with the protected associative array <code> $translators </code> that associate a language id
          with a content processor function that translate language content elements in Resource Model according the
          language id. Content negotiation policy provide the public <code> translators() </code> function that
          returns $translators variable. </dd>
      </dl>
      All Content negotiation policies provide the static method <code> render()</code> that renders a Resource model.
      This method is normally called by endpoint runtime engine, but you can call it by yourself (see above). Core
      package provides a set of "ready to use" content negotiation policies detailed above. <br>
      <h2 id="ResponsePolicy">Negotiating contents in Response</h2>
      <p> Response content negotiation involves Renderers and Serializers. </p>
      <p> In Core package you can choose how to manage content negotiation in HTTP responses selecting one of these
        methods: </p>
      <ol>
        <li> using a policy and taking into "Accept" header in client request, you can attach a policy "per route" or
          using using the same policy policy for all routes. see above from more info about "accept processing" </li>
        <li> create dynamically a rendering policy in "accept processing" </li>
        <li> directly provide a resource state representation. In this&nbsp; case you are responsible to set proper HTTP
          Content-type header and to returning a string or an object that supports <code> __toString()</code> magic
          methods or an open stream to the endpoint run-time engine. </li>
        <li> call directly policy render() method and pass the result to rendering policy. </li>
      </ol>
      <p> In any case remember that it is your responsibility to use a policy that it is compatible with your resource
        model or you can easily incur in a run-time error. </p>
      <h3 id="accept">Accept processing</h3>
      <p> "Accept" is a set of HTTP header optionally specified by client that states the client preferences for
        resource representation.Endpoint binds the available renderers to client desiderata with the <code> accept() </code>
        method. </p>
      <p> For example, these two routes use same controller but they my accept different policies for content
        negotiation: </p>
      <pre><code id="Hypermedia">$this-&gt;get('/simplest', 'myHelloController'); // no content negotiation
$this-&gt;get('/simple', 'myHelloController')<strong>-&gt;accept(Standard::renderes())</strong>;
</code></pre>
      <p> Note that if no content negotiation policy is defined, the controller itself must take the responsibility for
        model state rendering. </p>
      <p> In this example there are three different routes with different controllers that share same content management
        policy: </p>
      <pre><code>$this-&gt;get('/route1', 'Controller1');
$this-&gt;get('/route2', 'Controller2');
$this-&gt;get('/route3', 'Controller3');

$this-&gt;<strong>always('Accept',Standard::renderers())</strong>;
</code></pre>
      <p> The content negotiation policy by accept processing can be <em>forced</em> to select a particular
        representation bypassing HTTP protocol specifying a medium in resource uri the client request in variable <var>_output</var>
        . For instance to force xml rendering of a resource ignoring the content preferences specified in HTTP header
        you can use : <code> HTTP://...endpoint_uri?_output=application/xml </code> . </p>
      <p> You can also define dynamically representations </p>
      <pre>    $app-&gt;get('/about', function() {
        return array('v' =&gt; 2.0);
    })-&gt;acceptLanguage(array(
        'en' =&gt; function($data) { return array("Version" =&gt; $data['v']); },
        'pt' =&gt; function($data) { return array("Versão"  =&gt; $data['v']); }
    ))-&gt;accept(array(
        'text/html' =&gt; function($data) {
            list($k,$v)=each($data);
            return "$k: $v";
        },
        'application/json' =&gt; 'json_encode'
    ));</pre>
      <p> See Respect\Rest documentation for some examples about <code> accept() </code> usage. </p>
      <h2 id="restoring">Negotiating contents in Requests</h2>
      <p> It is a process performed by controller that restore the status of a Resource model from its representation
        provided by client in HTTP request. The process is performed by <code> setState()</code> Controller method that
        accepts as first parameter a resource model instance and as second parameter an associative array of property
        =&gt; value or a parsable string representation of a PHP variable (that typically, but non necessary, was
        produced by <a href="http://php.net/manual/en/function.var-export.php"><code> var_export()</code></a> PHP
        function). </p>
      <h2 id="customizingCNP">Customizing Content Negotiation Policies</h2>
      <p> To create your own content negotiation policy you just deriving an existing Custom Negotiation Class. </p>
      <h3>Redefine an existing rendering</h3>
      <p> In this example see how to redefine standard html renderer using a custom templating design: </p>
      <pre><code>use BOTK\Core\Representations\Standard;
class MyStandard extends Standard
{
    public static function htmlRenderer($data)
    {
        if(ob_start()){
            require 'myhtml_template.php';
            $result = ob_get_contents();
            ob_end_clean();
        }
        return $result;
    }
}</code></pre>
      <h3>Change the list of supported renderers</h3>
      <p> As example remove html and text support from standard policy: </p>
      <pre><code>use BOTK\Core\Representations\Standard;
class MyStandard extends Standard
{
    protected static $renderers = array(
        'application/json'  =&gt; 'json_encode',// PHP standard function
        'application/xml'   =&gt; 'xmlRenderer', 
        'application/x-php' =&gt; 'serialize',// PHP standard function
    ); 
}</code></pre>
      <h3>Create a new content negotiation</h3>
      <p> Example of new policy reusing an existing renderer, redefining one one and creating a new one; </p>
      <pre><code>use BOTK\Core\Representations\Standard;
class MyPolicy extends AbstractContentNegotiationPolicy
{    
    protected static $renderers = array(
        'application/json' =&gt; array('\\BOTK\\Core\\Representations\\Standard', 'jsonRenderer',
        'text/plain' =&gt; 'plaintextRenderer',
        'application/myapplication+xml' =&gt; 'myRenderer',
    ); 
	
    public static function plaintextRenderer($data)
    {
        header('Content-Type: text/plain');
        return print_r($data, true);
    }
	
    public static function myRenderer($data)
    {
        header('Content-Type: application/myapplication+xml');
        return Sample::xmlSerializer($data, true, <br>           'HTTP://myurl/myversyspecialxmlstyle.css',<br>           </code><code><code>'HTTP://myurl/myversyspecialxmlstyle.xslt'</code>);
    }

}</code></pre>
    </section>
    <section>
      <h2 id="defaultPolicies">Predefined content negotiation policies</h2>
      <h3 id="Standard">Standard</h3>
      <p> This content negotiation policy is designed for applications that use generic PHP data structure as Resource
        Model. </p>
      <p> It provide following response and request representations: </p>
      <pre>    protected static $renderers = array(
        'application/json'          =&gt; 'jsonRenderer',
        'application/xml'           =&gt; 'xmlStandardRenderer', 
        'text/html'                 =&gt; 'htmlRenderer',
        'application/x-php'         =&gt; 'serialphpRenderer',
        'text/x-php'                =&gt; 'phpRenderer',
        'text/plain'                =&gt; 'plaintextRenderer',
    );
    
    protected static $parsers = array(
        'application/json'          =&gt; 'jsonRestorer',
        'application/standard+xml'  =&gt; 'xmlStandardRestorer', 
        'application/x-php'         =&gt; 'serialphpRestorer',
    );</pre>
      Standard class define following renderer functions: <br>
      <dl>
        <dt>Standard::jsonRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> Serializes data structure using <code> json_encoder() </code> standard PHP function </dd>
        <dt>Standard::xmlStandardRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> Create a valid xml using <a href="#xmlSerializer">xmlSerializer()</a>. It uses <code>
            static::$xmlProcessingInstructions </code> static array to drive serializer. </dd>
        <dt>Standard::htmlRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> Serializes data structure using <a href="#htmlSerializer">htmlSerializer()</a>. It uses <code>
            static::$htmlMetadata </code> static array , to drive serializer. If <code> static::$htmlMetadata </code>is
          an array it assume that each array element is an html&nbsp; header, if it is a string it assume that it is the
          url of a css. </dd>
        <dt>Standard::plaintextRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> Serializes data structure using <a href="#textSerializer">textSerializer()</a>. </dd>
        <dt>Standard::serialphpRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> serializes data structure using <code> serialize() </code> standard PHP function. </dd>
        <dt>Standard::phpRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> Renders the input data sing <code> var_export() </code> standard PHP function . It can be used for
          passing PHP code to the client to fulfil "code on demand" REST architecture constraint. It is client
          responsibility to interpret and execute the code. </dd>
        <dt>Standard::htmlTemplateRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> a very simple template engine to reneder html using a custom PHP script. As template file it uses the path
          contained in <code> static::$htmlTemplate </code> that defaults to 'templates/html_template.php'. </dd>
      </dl>
      <p> All Standard renderers display only visible properties of input $data. </p>
      <p> Standard class define following serializers: </p>
      <dl>
        <dt id="htmlSerializer">htmlSerializer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data, array $metadata = array(), $type = '', $header='', $footer='')</dt>
        <dd> display data as semantic tagged html5, if metadata is empty it produce just an html fragment . It use
          textSerializer to show data. </dd>
        <dt id="textSerializer">plaintextSerializer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> it is like print_r PHP function but operates only on visible (public) vars on objects. </dd>
        <dt>phpSerializer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data, $templateFile)</dt>
        <dd> it is a pseudo-serializer that symply include a PHP script that must render $data. </dd>
        <dt id="xmlSerializer">xmlSerializer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data, array $processingInstructions=array(),$rootElement=null)</dt>
        <dd> Serialize data structure using <a href="#Xmlon">Xmlon</a> class encode method. If empty
          $prorcessingInstruction provided an invalid xml fragment is produced. </dd>
        <dt>templateSerializer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data, $template)</dt>
        <dd> it is a micro template engine that just include $template file passing all public variables of data to it
          as $data. </dd>
        <dt>htmlWebLinkSerializer(WebLink $link)</dt>
        <dd> serialize a weblink as an html link header tag. </dd>
      </dl>
      <p> Standard class define following parser functions: <br>
      </p>
      <dl>
        <dt>Standard::jsonRestore(mixed $resource, string $representation)</dt>
        <dd> UnSerializes $representation structure in $resource using <code> json_decoder() </code> standard PHP
          function. Decoder representation type must match $resource one. </dd>
        <dt>Standard::xmlStandardRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> UnSerializes $representation structure in $resource using <a href="#xmlParser">xmlParser()</a>.Decoder
          representation type must match $resource one. </dd>
        <dt>Standard::serialphpRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> UnSerializes $representation structure in $resource using <code> unserialize() </code> standard PHP
          function. Decoder representation type must match $resource one. </dd>
      </dl>
      <p> Standard class define following parsers functions: <br>
      </p>
      <dl>
        <dt>Standard::xmlStandardRenderer(<a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">mixed</a>
          $data)</dt>
        <dd> UnSerializes $representation structure in $resource using <a href="#xmlParser"> </a><a href="#Xmlon">Xmlon</a>
          decode method </dd>
      </dl>
      <h4>Runtime customizing of Standard policy</h4>
      <p> Some default serializers allow a sort of personalization if some variables are defined in the policy. For
        example to change the css in html generate by Standard policy use: </p>
      <pre><code>    /**
     * Allow to personalize xml header in xmlStandardRenderer
     */
    public static $xmlProcessingInstruction = array(
        '&lt;?xml version="1.0" encoding="UTF8"?&gt;',
    );
     
    /**
     * Allow htmlRenderer to personalize html headers
     */
    public static $htmlMetadata = array(
        '&lt;link rel="stylesheet" type="text/css" href="HTTP://www.w3.org/StyleSheets/TR/base" /&gt;'
    );

    /**
     * If using htmlTemplateRenderer allow you to define the template path
     */
    public static $htmlTemplate = 'templates/html_template.php';
    </code><code>
</code></pre>
      <h3 id="ErrorRepresentation">Error</h3>
      <p> Core Pachage provides a specialization of Standad Content Management policy&nbsp; to support <code>
          Core\Models\HttpProblem</code> data model. It is used by Error Manager to display http errors. </p>
      <p> It provide following response and request representations: </p>
      <pre>    protected static $renderers = array(
        'application/api-problem+json' =&gt; 'jsonErrorRenderer',
        'application/json'          =&gt; 'jsonErrorRenderer',
        'application/xml'           =&gt; 'xmlStandardRenderer', 
        'text/html'                 =&gt; 'htmlErrorRenderer',
        'application/x-php'         =&gt; 'serialphpRenderer',
        'text/x-php'                =&gt; 'phpRenderer',
        'text/plain'                =&gt; 'plaintextRenderer',
    );
    
</pre> Standard class redefine from Standard following renderer functions: <br>
      <dl>
        <dt>Error::htmlErrorRenderer(HttpProblem $data)</dt>
        <dd> It uses <code> static::$htmlMetadata </code> static array , to print html header. If <code>
            static::$htmlMetadata </code>is an array it assume that each array element is an html&nbsp; header, if it
          is a string it assume that it is the url of a css. </dd>
        <dt>Error::jsobErrorRenderer(HttpProblem $data)</dt>
        <dd> Render http proiblem as <a href="ttp://tools.ietf.org/html/draft-nottingham-http-problem-04">application/api-problem+json
            </a> </dd>
      </dl>
      <h4>Runtime customizing of Error policy</h4>
      <p> You can change the display style error just setting <code> static::$htmlMetadata </code> . For example to
        change the css in html generate by Standard policy use: </p>
      <pre><code>public static $htmlMetadata ="HTTP://www.w3.org/StyleSheets/TR/base" /&gt;';</code><code>
</code></pre> </section>
    <h1 id="httpCaching">HTTP Caching</h1>
    <p> HTTP cache management is related to the to generation of ETag and "Last-Modified" header. Beside this Etag and
      Last-Modified should be cheched against if-none-match and if-modified-since header requests. </p>
    <p> ETag is used for two purposes: </p>
    <ul>
      <li> to avoid to send a response body already known by client </li>
      <li> to manage concurrency </li>
    </ul>
    <p> Unfortunatelly the two objectives do not match well: to reach firs objective you should calculate the ETag on
      Resource Representation. To reach second objective sholud be preferable to calculate ETag on Resource model. Core
      Package adopt a simple solution. You can call caching multiple times. Each time a new ETag wil be calculated
      appending a new value to existing one. </p>
    <p> There are two entrypoint for managing caching: </p>
    <ul>
      <li> at Controller level through method <code> resouceCachingProcessor() </code> that accepts a resource and,
        optionally one time constant exported by <a href="#Caching">Caching</a> class </li>
      <li> atEndpoint level through method <code> representationCachingProcessor() </code> that accepts one of caching
        algorithm exported by <a href="#Caching">Caching</a> class. </li>
    </ul>
    <p> You can call none, one or both entry points to manage cache For example: </p>
    <pre><code>class HellowordController extends Controller
{
    public function get()
    {
        return self::stateTransfer(
            <strong>$this-&gt;resouceCachingProcessor(new HelloworldModel)</strong>,
            WebLink::factory('HTTP://e-artspace.com/')-&gt;rel('sender')
        );
    }
}

class HelloWorld extendsEndpoint
{
    protected function setRoutes()
    {
        $this-&gt;get('/', 'HellowordController')
            -&gt;accept(Standard::representations())
            <strong>-&gt;through($this-&gt;representationCachingProcessor())</strong>
    }
}</code></pre>
    <p> This will return to client following header: </p>
    <pre><code>after resource caching: ETag : <strong>"123123a1523671351"</strong>
after representation caching:  ETag: <strong>"123123a1523671351/</strong><strong>123126371235611"</strong>
</code></pre>
    <p> A client can parse ETag and decide if use all Etag or just the first part (i.e. the weak ETag). Core package
      caching supports partial ETag matching. </p>
    <p> Both <code> resouceCachingProcessor() </code> and <code> representationCachingProcessor() </code> accetp an
      additional parameter to specify a cache-control header max-age. In particular <code> resouceCachingProcessor() </code>
      accepts a positive integer that represents the estimate of number of second the resource should remain fresh (0=no
      chaching), while <code> representationCachingProcessor() </code> espects one of predefined algorithm in <a href="#Caching">Caching</a>
      class. For example: </p>
    <pre><code>representationCachingProcessor(); // 0 sec of Max-Age equivalent to
representationCachingProcessor(Caching::NO); // 0 sec of Max-Age
representationCachingProcessor(Caching::DOS_PROTECTION); // 3 sec of Max-Age
representationCachingProcessor(Caching::SHORT); // 30 sec of Max-Age
representationCachingProcessor(Caching::CONSERVATIVE); // 180 sec of Max-Age
representationCachingProcessor(Caching::AGGRESSIVE); // one hour of Max-Age
representationCachingProcessor(Caching::VERY_AGGRESSIVE); // one day of Max-Age
...
resourceCachingProcessor(new HelloworldModel,3) // 3 sec of Max-Age
</code></pre>
    <section>
      <h1 id="errorManagement">Error Management</h1>
      <p> Core package ErrorManager class provides helpers to automatically translate all Exceptions in HTTP error
        response, providing a client with all information about occurred error. Error management try to be consistent
        with last available <a href="http://tools.ietf.org/html/draft-nottingham-http-problem-04">http_problem proposal</a>
        RFC managing <code> BOTK\Core\Models\HttpProblem</code> data structure. ErrorManager class uses <a href="#ErrorRepresentation">Content
          Management Error Representations</a> to render an http problemrepresentation. </p>
      <p> Core package and ErrorManager adopts <a href="http://php.net/manual/en/language.exceptions.php">PHP exception
          management</a>. </p>
      <h3>To enable error management</h3>
      <p> Error management is a singleton to be use in main web service script: </p>
      <pre><code>try {                                                      
    echoEndpointFactory::make('MyEndPoint')-&gt;run();
} catch ( Exception $e) {
    echo </code><code><code> ErrorManager::getInstance()</code>-&gt;render($e); 
}</code></pre>
      <p> ErrorManager can translate any PHP error in Exception for an homogeneous error management: </p>
      <pre><code>$errorManager = ErrorManager::getInstance()-&gt;registerErrorHandler(); 
try {                                                      
    echoEndpointFactory::make('MyEndPoint')-&gt;run();
} catch ( Exception $e) {
    echo $errorManager-&gt;render($e); 
}</code></pre>
      <h3>To generate an error </h3>
      <p> in your code service simply: </p>
      <pre><code>$problem = new HttpProblem(
  404, // the Http status to return
  'short description of the error',
  'http://example.org/error/description/', // uri that describe this error
  'http://example.org/error/class/description/' // uri that describe this error type
);
throw new HttpErrorException($problem);</code></pre>
      <p> You can use <code> null</code> to indicate to Error management to use defaults for parameters: all parameters
        in HttpProblem have a default value, so they do not need to be specified: </p>
      <pre><code>throw new HttpErrorException(); // throws a 500 http error<br></code><code>throw new HttpErrorException(new HttpProblem(404)); // throws a 404 http error</code></pre>
      <p> You are not forced to use HttpErrorException, you can throw any PHP Exception, if error code is between 400
        and 599 appropriate HTTP Status will be selected. </p>
      <p> Finally you can ask content manager to direct serialize an http problem taking into account request
        preferences: </p>
      <pre><code>echo ErrorManager::getInstance()-&gt;serializeHttpProblem(</code><code><code>new HttpProblem(404)</code>); </code></pre>
      <h3>To customize error display policy</h3>
      <p> You can instruct Error Management to use your custom Content Negotiation Policy to render errors: </p>
      <pre><code>class myErrorRenderingPolicy extends BOTK\Core\Representations\Error{
	public static function htmlRenderer($error) {return 'Opss!';}
}
ErrorManager::getInstance()-&gt;setContentPolicy('myErrorRenderingPolicy'); </code></pre>
      <h3 id="errors"> HTTP Error Status codes</h3>
      <p> Core package can throw this errors types: </p>
      <dl>
        <dt>400 Bad Request</dt>
        <dd> when a field validation fails </dd>
        <dt>404 Not Found</dt>
        <dd> on invalid or not found endpoint in application </dd>
        <dd> when no matching route paths are found </dd>
        <dt>401 Unauthorized</dt>
        <dd> when the client sends an unauthenticated request to a route using authBasic routine. </dd>
        <dt>405 Method Not Allowed</dt>
        <dd> when a matching path is found but the method isn't specified. </dd>
        <dt>406 Not Acceptable</dt>
        <dd> when the route path and method matches but content-negotiation doesn't </dd>
        <dt>500 Internal Server Error</dt>
        <dd> on invalid class types or unknown server errors </dd>
      </dl>
      <p> When an HTTP Error status is returned, the response body will contain an http problem representation; if
        possible the http problem serialization takes care of the <em>accept HTTP </em>header in request, it returns a
        json structure otherwise. </p>
    </section>
    <section>
      <h1 id="Helpers">Other classes, interfaces and helpers</h1>
      <h2 id="Singleton">Singleton Class</h2>
      <p> Just a very basic implementation of Singleton design pattern in php 5.3 . This implememtaton works with
        multiple sublclasses. </p>
      <h2 id="SimpleTemplateEngine">SimpleTemplateEngine Class</h2>
      <p>This class implements a very simple template engine providing some public methods:</p>
      <ul>
        <li><code>__construct($template='',$openDelimiter = '{', $closeDelimiter = '}')</code>: the constructor</li>
        <li><code>factory($template='',$openDelimiter = '{', $closeDelimiter = '}')</code>: the static method to cal
          constructur </li>
        <li><code>setTemplate($string)</code>: sets the template from a string.</li>
        <li><code>setFromFile($file)</code>: sets the template from a string.</li>
        <li><code>setVars(array $values, $merge = TRUE)</code>: sets one or more template variables.</li>
        <li> <code>addVar($tag,$value)</code>:add a single template variables.</li>
        <li><code>render()</code>: renders the template and returns the result as a string. Also available as __toString</li>
        <li><code>renderToFile($target)</code>: renders the template and writes the result to a file.</li>
      </ul>
      <p><br>
      </p>
      <h2 id="Http">Http Class</h2>
      <p> This helper&nbsp; provides a set of few functions that are not natively present in supported version of PHP,
        mainly related to parsing and managing of HTTP headers. </p>
      <h2 id="Caching">Caching</h2>
      <p> This class provides a set of constant and functions for managing HTTP caching protocol </p>
      <h2 id="Cacheable">Cacheable interface</h2>
      <p> Php classes can optionally a couple of functions to help HTTP caching management: </p>
      <dl>
        <dt>string getETag()</dt>
        <dd> returns a string that uniquely identify the resource state. Used by <code> Caching::setETagHeader() </code>
        </dd>
        <dt>DateTime getLastUpdateDate()</dt>
        <dd> returns a DateTime structure that identify the last update time of the resouce state. Used by <code>
            Caching::setLastModifiedHeader() </code> </dd>
      </dl>
      <h2 id="WebLink">WebLink</h2>
      <p> this class models WebLink according to rfc5988 </p>
      <h2 id="Mimepars">External packages and credits</h2>
      <p> Core package use some great libraries that you can reuse in your code. </p>
      <h3 id="MimeParser">Bitworking\Mimeparse</h3>
      <p> This library provides basic functionality for parsing mime-types names and matching them against a list of
        media-ranges. See section 14.1 of <a href="http://tools.ietf.org/html/rfc2616">RFC 2616 (the HTTP
          specification)</a> for a complete explanation. More information on the library can be found in the XML.com
        article "<a href="http://www.xml.com/pub/a/2005/06/08/restful.html">Just use Media Types</a>? </p>
      <p> Mimeparse is used by Error manager to select the proper renderer to use. <br>
        <br>
        This library was taken by Joe Gregorio from the <a href="http://code.google.com/p/mimeparse/">original
          mimeparse library on Google Project Hosting</a> and has been cleaned up to conform to <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">PSR-2</a>
        standards. It also now has support for <a href="http://getcomposer.org/">Composer</a>. The Bitworking namespace
        is a nod to [<a href="http://bitworking.org/">Joe Gregorio</a>, the original author of this library. </p>
      <h4>License</h4>
      <p> Copyright (c) 2010 Joe Gregorio <br>
        <br>
        Permission is hereby granted, free of charge, to any person obtaining a copy <br>
        of this software and associated documentation files (the "Software"), to deal <br>
        in the Software without restriction, including without limitation the rights <br>
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell <br>
        copies of the Software, and to permit persons to whom the Software is <br>
        furnished to do so, subject to the following conditions: <br>
        <br>
        The above copyright notice and this permission notice shall be included in <br>
        all copies or substantial portions of the Software. <br>
        <br>
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR <br>
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, <br>
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE <br>
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER <br>
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, <br>
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN <br>
        THE SOFTWARE. </p>
      <h3 id="RespectRest">Respect\Rest</h3>
      <p> Respect\Rest it used as main rest engine. EndPoit is an extension on Respect\Router. </p>
      <h4>License</h4>
      <p> Copyright (c) 2009-2013, Alexandre Gomes Gaigalas. <br>
        All rights reserved. <br>
        <br>
        Redistribution and use in source and binary forms, with or without modification, <br>
        are permitted provided that the following conditions are met: </p>
      <ul>
        <li> Redistributions of source code must retain the above copyright notice,this list of conditions and the
          following disclaimer. </li>
        <li> Redistributions in binary form must reproduce the above copyright notice this list of conditions and the
          following disclaimer in the documentation and/or other materials provided with the distribution. </li>
        <li> Neither the name of Alexandre Gomes Gaigalas nor the names of its contributors may be used to endorse or
          promote products derived from this software without specific prior written permission. </li>
      </ul>
      <p> <br>
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND <br>
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED <br>
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE <br>
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR <br>
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES <br>
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; <br>
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON <br>
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT <br>
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS <br>
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
      <p> <br>
      </p>
      <h3 id="Xmlon">Paranoiq\Xmlon</h3>
      <p> Simple xml serializer for scalar, array and PHP StdClass object. Used by Standard xmlRenderer </p>
      <h4>License</h4>
      <p> New BSD License <br>
        <br>
        Copyright (c) 2013 paranoiq All rights reserved. <br>
        <br>
        Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
        following conditions are met: </p>
      <ul>
        <li> Redistributions of source code must retain the above copyright notice,this list of conditions and the
          following disclaimer. </li>
        <li> Redistributions in binary form must reproduce the above copyright notice,this list of conditions and the
          following disclaimer in the documentationand/or other materials provided with the distribution. </li>
        <li> Neither the name of author nor the names of this software contributorsmay be used to endorse or promote
          products derived from this software without specific prior written permission. </li>
      </ul>
      <p> <br>
        This software is provided by the copyright holders and contributors "as is" and any express or implied
        warranties, including, but not limited to, the implied warranties of merchantability and fitness for a
        particular purpose are disclaimed. In no event shall the copyright owner or contributors be liable for any
        direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to,
        procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however
        caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or
        otherwise) arising in any way out of the use of this software, even if advised of the possibility of such
        damage. </p>
      <p> <br>
      </p>
    </section>
    <footer>
      <div id="footer">
        <!-- autogenerated footer --> </div>
    </footer>
  </body>
</html>
